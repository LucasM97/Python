6.1 Repaso de temas pasados
A continuación dejamos unos links a unos videos sobre un par de ejercicios de la clase 5:

Ejercicio Ejercicio 5.2 sobre la probabilidad de obtener una generala no servida resuelto por Matias y por Rafael.
Ejercicio Ejercicio 5.15 del álbum de Figuritas
Análisis de alternativas para propagar
Los siguientes tres ejercicios proponen diferentes soluciones al Ejercicio 4.6 de propagación del fuego. Vamos a analizar sus diferencias y comenzar a pensar en su eficiencia. Algunas soluciones tienen errores que deberás corregir oportunamente. ¡Usá el debugger de Python!

Observación: Cuando te pidamos que cuentes cuántas operaciones hace una función, no nos va a importar el detalle de las constantes. Por ejemplo: si una función para una entrada de largo n hace n+2 operaciones y otra hace 3n+5 nos va a importar que ambas hacen una cantidad lineal de operaciones en el tamaño de la entrada, pero no las constantes 2, 3 y 5 que figuran en cada caso. Diremos que la cantidad de operaciones es O(n) (se lee 'o de n'). En cambio, sí vamos a hacer una diferencia si una función hace n y otra hace n^2 operaciones (una va a tener complejidad O(n) y la otra O(n^2)). Volveremos sobre estos temas más adelante.

Ejercicio 6.1: Propagar por vecinos
El siguiente código propaga el fuego de cáda fósforo encendido a sus vecinos inmediatos (si son fósforos nuevos) a lo largo de toda la lista. Y repite esta operación mientras sea necesario. ¿Te animás a estimar cuántas operaciones puede tener que hacer, en el peor caso?

def propagar_al_vecino(l):
    modif = False
    n = len(l)
    for i,e in enumerate(l):
        if e==1 and i<n-1 and l[i+1]==0:
            l[i+1] = 1
            modif = True
        if e==1 and i>0 and l[i-1]==0:
            l[i-1] = 1
            modif = True
    return modif

def propagar(l):
    m = l.copy()
    veces=0
    while propagar_al_vecino(l):
        veces += 1

    print(f"Repetí {veces} veces la función propagar_al_vecino.")
    print(f"Con input {m}")    
    print(f"Y obtuve  {l}")
    return m
#%%
propagar([0,0,0,0,1])
propagar([0,0,1,0,0])
propagar([1,0,0,0,0])
Preguntas:

¿Por qué los tests l[i+1]==0 y l[i-1]==0 de la función propagar_al_vecino no causan un IndexError en los bordes de la lista?
¿Por qué propagar([0,0,0,0,1]) y propagar([1,0,0,0,0]), siendo entradas perfectamente simétricas, no generan la misma cantidad de repeticiones de llamadas a la función propagar_al_vecino?
Sobre la complejidad. Si te sale, calculá:
¿Cuántas veces como máximo se puede repetir el ciclo while en una lista de largo n?
¿Cuántas operaciones hace "propagar_al_vecino" en una lista de largo n?
Entonces, ¿cuántas operaciones hace como máximo esta versión de propagar en una lista de largo n? ¿Es un algoritmo de complejidad lineal o cuadrática?
Ejercicio 6.2: Propagar por como el auto fantástico
El siguiente código propaga el fuego inspirado en las luces del auto fantástico.

def propagar_a_derecha(l):
    n = len(l)
    for i,e in enumerate(l):
        if e==1 and i<n-1:
            if l[i+1]==0:
                l[i+1] = 1
    return l
#%
def propagar_a_izquierda(l):
    return propagar_a_derecha(l[::-1])[::-1]
#%
def propagar(l):
    ld=propagar_a_derecha(l)
    lp=propagar_a_izquierda(ld)
    return lp
#%%
l = [0,0,0,-1,1,0,0,0,-1,0,1,0,0]
print("Estado original:  ",l)
print("Porpagando...")
lp=propagar(l)
print("Estado original:  ",l)
print("Estado propagado: ",lp)
Preguntas:

¿Por qué se modificó la lista original?
¿Por qué no quedó igual al estado propagado?
Corregí el código para que no cambie la lista de entrada.
¿Cuántas operaciones hace como máximo propagar_a_derecha en una lista de largo n?
Sabiendo que invertir una lista ([::-1]) requiere una cantidad lineal de operaciones en la longitud de la lista ¿Cuántas operaciones hace como máximo propagar en una lista de largo n?
Ejercicio 6.3: Propagar con cadenas
Esta versión usa métodos de cadenas para resolver el problema separando los fósforos en grupos sin fósforos quemados y analizando cada grupo. Sin embargo algo falla...

def trad2s(l):
    '''traduce una lista con 1,0 y -1 
    a una cadena con 'f', 'o' y 'x' '''
    d={1:'f', 0 :'o', -1:'x'}
    s=''.join([d[c] for c in l])
    return s

def trad2l(ps):
    '''traduce cadena con 'f', 'o' y 'x'
    a una lista con 1,0 y -1'''
    inv_d={'f':1, 'o':0, 'x':-1}
    l = [inv_d[c] for c in ps]
    return l

def propagar(l, debug = True):
    s = trad2s(l)
    if debug:
        print(s)#, end = ' -> ')
    W=s.split('x')
    PW=[w if ('f' not in w) else 'f'*len(w) for w in W]
    ps=''.join(PW)
    if debug:
        print(ps)
    return trad2l(ps)

#%%
l = [0,0,0,-1,1,0,0,0,-1,0,1,0,0]
lp = propagar(l)
print("Estado original:  ",l)
print("Estado propagado: ",lp)
Preguntas:

¿Porqué se acorta la lista?
¿Podés corregir el error agregando un solo caracter al código?
¿Te parece que este algoritmo es cuadrático como el Ejercicio 6.1 o lineal como el Ejercicio 6.2?